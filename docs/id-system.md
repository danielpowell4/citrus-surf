# ID System Documentation

## Overview

The Citrus Surf ID system provides robust, vendor-prefixed unique identifiers for all data entities. This system ensures data integrity, enables reliable row tracking, and maintains clear separation between user-defined and system-managed identifiers.

## Core Concepts

### Dual ID Architecture

The system maintains two types of identifiers:

1. **User IDs**: User-defined, editable identifiers for business logic
2. **System IDs**: Vendor-prefixed, unique identifiers for system operations

### Vendor Prefixing

All system-generated IDs use the `cs_` prefix (Citrus Surf) to clearly identify data generated by our system:

```typescript
// Examples of vendor-prefixed IDs
cs_01H9X2K3L4M5N6P7Q8R9S0T1U; // Row ID
cs_01H9X2K3L4M5N6P7Q8R9S0T1U2; // Another row ID
```

## ID Types and Generation

### Row IDs

Row IDs are automatically injected during data import:

```typescript
import { generateRowId } from "@/lib/utils/id-generator";

// Generate a unique row ID
const rowId = generateRowId(); // "cs_01H9X2K3L4M5N6P7Q8R9S0T1U"
```

### Target Shape IDs

Target shapes use their own prefix:

```typescript
import { generateShapeId } from "@/lib/utils/id-generator";

// Generate a unique shape ID
const shapeId = generateShapeId(); // "shape_01H9X2K3L4M5N6P7Q8R9S0T1U"
```

### Field IDs

Fields within shapes have their own prefix:

```typescript
import { generateFieldId } from "@/lib/utils/id-generator";

// Generate a unique field ID
const fieldId = generateFieldId(); // "field_01H9X2K3L4M5N6P7Q8R9S0T1U"
```

### Template IDs

Templates use a shortened prefix:

```typescript
import { generateTemplateId } from "@/lib/utils/id-generator";

// Generate a unique template ID
const templateId = generateTemplateId(); // "tmpl_01H9X2K3L4M5N6P7Q8R9S0T1U"
```

## ID Generation System

### ULID Foundation

The system uses ULID (Universally Unique Lexicographically Sortable Identifier) for all IDs:

- **Uniqueness**: Guaranteed unique across distributed systems
- **Sortability**: Lexicographically sortable by creation time
- **Compact**: 26 characters, URL-safe
- **Time-based**: First 10 characters encode timestamp

### Prefix System

```typescript
export const ID_PREFIXES = {
  SHAPE: "shape",
  FIELD: "field",
  TEMPLATE: "tmpl",
  VALIDATION: "val",
  TRANSFORMATION: "trans",
  ROW: "cs", // Vendor prefix for row IDs
} as const;
```

### Generation Functions

```typescript
// Core generation function
export const generateId = (prefix: string): string => {
  return `${prefix}_${ulid()}`;
};

// Convenience functions
export const generateRowId = () => generateId(ID_PREFIXES.ROW);
export const generateShapeId = () => generateId(ID_PREFIXES.SHAPE);
export const generateFieldId = () => generateId(ID_PREFIXES.FIELD);
export const generateTemplateId = () => generateId(ID_PREFIXES.TEMPLATE);
```

## Row ID Injection

### Import Process

During data import, the system automatically injects vendor-prefixed row IDs:

```typescript
import { injectRowIds } from "@/lib/utils/data-processing";

// Process imported data
const processedData = injectRowIds(rawData);

// Result: Each row gets a _rowId field
[
  {
    id: "EMP001", // User ID (preserved)
    _rowId: "cs_01H9X2K3L4M5N6P7Q8R9S0T1U", // System ID (injected)
    firstName: "John",
    lastName: "Doe",
  },
];
```

### Data Processing Function

```typescript
export function injectRowIds(data: any[]): any[] {
  return data.map((row, index) => {
    const processedRow = { ...row };

    // Generate vendor-prefixed row ID
    const rowId = generateRowId();

    // Inject into hidden field
    processedRow._rowId = rowId;

    // Preserve existing user ID
    return processedRow;
  });
}
```

## Table Integration

### Row Identification

The table system uses internal IDs for reliable row tracking:

```typescript
const table = useReactTable({
  data,
  columns,
  getRowId: row => row._rowId!, // Use vendor-prefixed internal IDs
  // ... other configuration
});
```

### Column Configuration

User IDs are displayed as editable columns:

```typescript
const simpleColumns: SimpleColumnDef<Person>[] = [
  {
    accessorKey: "id",
    header: "ID",
    size: 80,
    meta: {
      editable: {
        type: "text",
        placeholder: "Enter ID",
        maxLength: 20,
      },
    },
  },
  // ... other columns
];
```

## ID Validation

### Format Validation

The system validates ID format:

```typescript
export const isValidId = (id: string, prefix?: string): boolean => {
  const idPattern = /^[a-z]+_[0-9A-Z]{26}$/;
  if (!idPattern.test(id)) return false;

  if (prefix) {
    return id.startsWith(`${prefix}_`);
  }

  return true;
};
```

### Prefix Extraction

```typescript
export const getPrefixFromId = (id: string): string | null => {
  const match = id.match(/^([a-z]+)_/);
  return match ? match[1] : null;
};

// Examples
getPrefixFromId("cs_01H9X2K3L4M5N6P7Q8R9S0T1U"); // "cs"
getPrefixFromId("shape_01H9X2K3L4M5N6P7Q8R9S0T1U"); // "shape"
```

## User Experience

### Visible vs Hidden IDs

- **User ID (`id`)**: Visible in table, editable by users
- **System ID (`_rowId`)**: Hidden from display, used internally

### Editing Behavior

```typescript
// Users can edit their IDs
const handleCellEdit = (rowId: string, columnId: string, value: any) => {
  if (columnId === "id") {
    // Update user ID - system ID remains unchanged
    updateCell({ rowId, columnId, value });
  }
};
```

### Data Export

Both IDs are preserved during export:

```typescript
// Export includes both user and system IDs
const exportData = [
  {
    id: "EMP001", // User ID
    _rowId: "cs_01H9X2K3L4M5N6P7Q8R9S0T1U", // System ID
    firstName: "John",
    lastName: "Doe",
  },
];
```

## Benefits

### Data Integrity

- **Unique Identification**: Every row has a guaranteed unique internal ID
- **Reliable Operations**: Table operations work consistently regardless of user ID format
- **Conflict Prevention**: No risk of ID collisions between different data sources

### User Flexibility

- **Meaningful IDs**: Users can define business-relevant identifiers
- **Editable**: Users can modify IDs without affecting system operations
- **Familiar**: Users work with their own ID conventions

### System Reliability

- **Vendor Identification**: Clear identification of Citrus Surf-generated data
- **Future-Proof**: ULID format provides sortable, unique identifiers
- **Scalable**: Supports distributed systems and high-volume data

### Development Benefits

- **Type Safety**: Strong typing for ID fields
- **Validation**: Built-in ID format validation
- **Debugging**: Clear identification of system vs user data
- **Migration**: Easy to identify and migrate Citrus Surf data

## Best Practices

### For Users

1. **Use Meaningful IDs**: Choose IDs that make sense for your data
2. **Be Consistent**: Use consistent ID formats within your datasets
3. **Keep IDs Short**: Avoid extremely long IDs for better usability
4. **Avoid Special Characters**: Stick to alphanumeric characters and common symbols

### For Developers

1. **Always Use System IDs**: Use `_rowId` for internal operations
2. **Preserve User IDs**: Never overwrite user-defined IDs
3. **Validate IDs**: Use validation functions when processing external data
4. **Handle Missing IDs**: Provide fallbacks for data without system IDs

## Integration Points

### Target Shapes

Target shapes use the ID system for:

- Shape identification (`shape_` prefix)
- Field identification (`field_` prefix)
- Template identification (`tmpl_` prefix)

### History System

The history system tracks changes using row IDs:

- Row selection uses internal IDs
- Cell editing references internal IDs
- State restoration preserves ID relationships

### Export System

The export system preserves both ID types:

- User IDs for business context
- System IDs for data integrity

## Future Enhancements

### Potential Improvements

1. **Custom Prefixes**: Allow users to define custom ID prefixes
2. **ID Migration**: Tools for migrating between ID formats
3. **Bulk ID Operations**: Batch operations for ID management
4. **ID Analytics**: Insights into ID usage patterns
5. **External ID Mapping**: Support for external system ID mapping

### Adding New ID Types

To add a new ID type:

1. **Add Prefix**: Add to `ID_PREFIXES` constant
2. **Add Generator**: Create convenience function
3. **Update Validation**: Extend validation patterns if needed
4. **Update Documentation**: Add examples and usage patterns

This ID system provides the foundation for reliable, scalable data management in the Citrus Surf platform.
